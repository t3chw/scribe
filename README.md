# Social Scribe ü§ñüìù‚ú®

**Stop manually summarizing meetings and drafting social media posts! Social Scribe leverages AI to transform your meeting transcripts into engaging follow-up emails and platform-specific social media content, ready to share.**

Social Scribe is a powerful Elixir and Phoenix LiveView application designed to connect to your calendars, automatically send an AI notetaker to your virtual meetings, provide accurate transcriptions via Recall.ai, and then utilize Google Gemini's advanced AI to draft compelling follow-up emails and social media posts through user-defined automation rules. This project was developed with significant AI assistance, as encouraged by the challenge, to rapidly build a feature-rich application.

---

## üåü Key Features Implemented

* **Google Calendar Integration:**
    * Seamlessly log in with your Google Account.
    * Connect multiple Google accounts to aggregate events from all your calendars.
    * View your upcoming calendar events directly within the app's dashboard.
* **Automated Meeting Transcription with Recall.ai:**
    * Toggle a switch for any calendar event to have an AI notetaker attend.
    * The app intelligently parses event details (description, location) to find Zoom or Google Meet links.
    * Recall.ai bot joins meetings a configurable number of minutes before the start time (currently default, setting to be added to UI).
    * **Bot ID Management:** Adheres to challenge constraints by tracking individually created `bot_id`s and not using the general `/bots` endpoint.
    * **Polling for Media:** Implements a robust polling mechanism (via Oban) to check bot status and retrieve transcripts/media, as webhooks cannot be used with the shared API key.
* **AI-Powered Content Generation (Google Gemini):**
    * Automatically drafts a follow-up email summarizing key discussion points and action items from the meeting transcript.
    * **Custom Automations:** Users can create, view, and manage automation templates, defining custom prompts, target platforms (LinkedIn, Facebook), and descriptions to generate specific marketing content or other post types.
* **Social Media Integration & Posting:**
    * Securely connect LinkedIn and Facebook accounts via OAuth on the Settings page.
    * **Direct Posting:** Generated content can be posted directly to the user's connected LinkedIn profile or a user-managed Facebook Page.
* **Meeting Management & Review:**
    * View a list of past processed meetings, showing attendees, start time, and platform logo (platform logo to be enhanced).
    * Click into any past meeting to view its full transcript, the AI-generated follow-up email draft, and a list of social media posts generated by configured automations.
    * **Copy & Post Buttons:** Social media drafts are presented with a "Copy" button (implemented via JS Hooks) for easy content reuse and direct "Post" buttons for integrated platforms.
* **Modern Tech Stack & Background Processing:**
    * Built with Elixir & Phoenix LiveView for a real-time, interactive experience.
    * Utilizes Oban for robust background job processing (calendar syncing, bot status polling, AI content generation).
    * Secure credential management for all connected services using Ueberauth.

---

## üîó Salesforce Integration (New)

Full Salesforce CRM integration following the same architecture as HubSpot, designed to make adding future CRMs straightforward.

### Salesforce OAuth

* **Custom Ueberauth Strategy:** `lib/ueberauth/strategy/salesforce.ex` ‚Äî handles authorization code flow with Salesforce's OAuth 2.0 endpoints
* **Credential Storage:** Stored in `user_credentials` with `provider: "salesforce"`, including `instance_url` in the `metadata` field (needed for all Salesforce API calls)
* **Token Refresh:** `Workers.CrmTokenRefresher` Oban cron worker (parameterized per provider) runs every 5 minutes, plus `with_token_refresh/2` wrapper auto-retries on 401

### Salesforce Contact Updates

* **Contact Search** ‚Äî Search Salesforce contacts via SOSL query
* **AI Suggestions** ‚Äî Gemini analyzes meeting transcript and suggests field updates (phone, email, job title, department, address)
* **Review & Apply** ‚Äî Same modal UI as HubSpot: see current vs suggested values, toggle fields on/off, batch-apply updates

### Salesforce Setup (Development)

1. Create a free Salesforce Developer Edition at [developer.salesforce.com](https://developer.salesforce.com)
2. Setup > App Manager > New Connected App
3. Enable OAuth, callback: `http://localhost:4000/auth/salesforce/callback`
4. Scopes: `api`, `refresh_token`, `offline_access`
5. Set `SALESFORCE_CLIENT_ID` and `SALESFORCE_CLIENT_SECRET` env vars

---

## üí¨ AI Chat Interface (New)

An AI-powered chat panel accessible from every dashboard page via the "Ask Anything" button.

* **Slide-out Panel** ‚Äî Opens from the right side of the screen with Chat and History tabs
* **CRM-Aware** ‚Äî Looks up contacts in both HubSpot and Salesforce (whichever is connected) to answer questions
* **Conversation History** ‚Äî Conversations are persisted and can be resumed from the History tab
* **Non-blocking** ‚Äî AI processing runs in a supervised async task so the LiveView stays responsive

---

## üèóÔ∏è Unified CRM Architecture

All CRM integrations share a single set of generic modules, parameterized by config from `CRM.ProviderConfig`:

| Layer | Module | Purpose |
|-------|--------|---------|
| Behaviour | `CrmApiBehaviour` | Single behaviour with 5 callbacks (`search_contacts`, `get_contact`, `update_contact`, `apply_updates`, `list_contacts`) + `impl/1` dispatcher |
| API Clients | `HubspotApi`, `SalesforceApi` | Per-provider implementations of `CrmApiBehaviour` |
| Config | `CRM.ProviderConfig` | Centralized provider config (field labels, AI prompts, UI styling) |
| Suggestions | `CrmSuggestions` | Generic AI-powered contact update suggestions from transcripts |
| Token Refresh | `Workers.CrmTokenRefresher` | Single Oban worker dispatching by `"provider"` arg |
| Modal UI | `CrmModalComponent` | Single parameterized LiveComponent for all CRMs |
| LiveView | `MeetingLive.Show` | 3 generic `handle_info` handlers for search/suggest/apply |
| AI | `AIContentGeneratorApi.generate_crm_suggestions/3` | Single callback, prompt templated from config |

### Adding a New CRM Provider

To add a new CRM (e.g. Pipedrive), follow these steps:

1. **Register the provider in `CRM.ProviderConfig`** (`lib/social_scribe/crm/provider_config.ex`):
   ```elixir
   "pipedrive" => %{
     name: "pipedrive",
     display_name: "Pipedrive",
     api_config_key: :pipedrive_api,
     field_labels: %{"firstname" => "First Name", ...},
     ai_field_descriptions: "- Phone numbers (phone)\n- Email ...",
     ai_field_names: "firstname, lastname, email, phone, ...",
     modal_submit_text: "Update Pipedrive",
     modal_submit_class: "bg-green-500 hover:bg-green-600",
     button_class: "bg-green-500 hover:bg-green-600"
   }
   ```

2. **Implement `CrmApiBehaviour`** in a new API module (e.g. `lib/social_scribe/pipedrive_api.ex`):
   ```elixir
   defmodule SocialScribe.PipedriveApi do
     @behaviour SocialScribe.CrmApiBehaviour
     # Implement: search_contacts/2, get_contact/2, update_contact/3, apply_updates/3, list_contacts/1
   end
   ```

3. **Create a token refresher** (e.g. `lib/social_scribe/pipedrive_token_refresher.ex`) implementing `SocialScribe.CrmTokenRefresherBehaviour`, and register it in the `@default_refreshers` map in `Workers.CrmTokenRefresher`.

4. **Add an Oban cron entry** in `config/config.exs`:
   ```elixir
   {"*/5 * * * *", SocialScribe.Workers.CrmTokenRefresher, args: %{"provider" => "pipedrive"}}
   ```

5. **Create Ueberauth OAuth strategy** (e.g. `lib/ueberauth/strategy/pipedrive.ex`) and add the route + callback handler in `AuthController`.

6. **Wire up the config** in `config/dev.exs` and `config/test.exs`:
   ```elixir
   config :social_scribe, :pipedrive_api, SocialScribe.PipedriveApi
   ```

7. **Register mock in `test/test_helper.exs`**:
   ```elixir
   Mox.defmock(SocialScribe.PipedriveApiMock, for: SocialScribe.CrmApiBehaviour)
   ```

That's it ‚Äî no changes needed to `CrmSuggestions`, `CrmModalComponent`, `MeetingLive.Show`, `ChatAI`, or any AI prompt logic. They all work generically off the provider config.

---

## App Flow

* **Login With Google and Meetings Sync:**
    ![Auth Flow](https://youtu.be/RM7YSlu5ZDg)

* **Creating Automations:**
    ![Creating Automations](https://youtu.be/V2tIKgUQYEw)

* **Meetings Recordings:**
    ![Meetings Recording](https://youtu.be/pZrLsoCfUeA)

* **Facebook Login:**
    ![Facebook Login](https://youtu.be/JRhPqCN-jeI)

* **Facebook Post:**
    ![Facebook Post](https://youtu.be/4w6zpz0Rn2o)

* **LinkedIn Login & Post:**
    ![LinkedIn Login and Post](https://youtu.be/wuD_zefGy2k)
---

## üì∏ Screenshots & GIFs


* **Dashboard View:**
    ![Dashboard View](readme_assets/dashboard_view.png)


* **Automation Configuration UI:**
    ![Automation Configuration](readme_assets/edit_automation.png)

---

## üõ† Tech Stack

* **Backend:** Elixir, Phoenix LiveView
* **Database:** PostgreSQL
* **Background Jobs:** Oban
* **Authentication:** Ueberauth (Google, LinkedIn, Facebook, HubSpot, Salesforce)
* **Meeting Transcription:** Recall.ai API
* **AI Content Generation:** Google Gemini API (Flash models)
* **Frontend:** Tailwind CSS, Heroicons (via `tailwind.config.js`)
* **Progress Bar:** Topbar.js for page loading indication.

---

## üöÄ Getting Started

Follow these steps to get SocialScribe running on your local machine.

### Prerequisites

* Elixir 1.18+ / Erlang/OTP 27+
* PostgreSQL
* Node.js (for Tailwind CSS asset compilation)

### Setup Instructions

1.  **Clone the Repository:**
    ```bash
    git clone https://github.com/fparadas/social_scribe.git
    cd social_scribe
    ```

2.  **Install Dependencies & Setup Database:**
    The `mix setup` command bundles common setup tasks.
    ```bash
    mix setup
    ```
    This will typically:
    * Install Elixir dependencies (`mix deps.get`)
    * Create your database if it doesn't exist (`mix ecto.create`)
    * Run database migrations (`mix ecto.migrate`)
    * Install Node.js dependencies for assets (`cd assets && npm install && cd ..`)

3.  **Configure Environment Variables:**
    You'll need to set up several API keys and OAuth credentials.
    * Copy the example environment file (if one is provided, e.g., `.env.example`) to `.env`.
    * Edit the `.env` file (or set environment variables directly) with your actual credentials:
        * `GOOGLE_CLIENT_ID`: Your Google OAuth Client ID.
        * `GOOGLE_CLIENT_SECRET`: Your Google OAuth Client Secret.
        * `GOOGLE_REDIRECT_URI`: `"http://localhost:4000/auth/google/callback"`
        * `RECALL_API_KEY`: Your Recall.ai API Key.
        * `RECALL_REGION`: Your Recall.ai region (e.g. `us-west-2`).
        * `GEMINI_API_KEY`: Your Google Gemini API Key.
        * `LINKEDIN_CLIENT_ID`: Your LinkedIn App Client ID.
        * `LINKEDIN_CLIENT_SECRET`: Your LinkedIn App Client Secret.
        * `LINKEDIN_REDIRECT_URI`: `"http://localhost:4000/auth/linkedin/callback"`
        * `FACEBOOK_CLIENT_ID`: Your Facebook App ID.
        * `FACEBOOK_CLIENT_SECRET`: Your Facebook App Secret.
        * `FACEBOOK_REDIRECT_URI`: `"http://localhost:4000/auth/facebook/callback"`
        * `HUBSPOT_CLIENT_ID`: Your HubSpot App Client ID.
        * `HUBSPOT_CLIENT_SECRET`: Your HubSpot App Client Secret.
        * `SALESFORCE_CLIENT_ID`: Your Salesforce Connected App Consumer Key.
        * `SALESFORCE_CLIENT_SECRET`: Your Salesforce Connected App Consumer Secret.

4.  **Start the Phoenix Server:**
    ```bash
    source .env && mix phx.server
    ```
    Or, to run inside IEx (Interactive Elixir):
    ```bash
    source .env && iex -S mix phx.server
    ```

Now you can visit [`localhost:4000`](http://localhost:4000) from your browser.

---

## Common Commands

```bash
mix setup                        # Full setup: deps, database, assets
mix phx.server                   # Start dev server
iex -S mix phx.server            # Start with IEx shell
mix test                         # Run all tests (332 tests)
mix test test/path/file.exs      # Run single test file
mix test test/path/file.exs:42   # Run test at line number
mix format                       # Format code
mix ecto.migrate                 # Run pending migrations
mix ecto.reset                   # Drop, create, migrate, seed
```

---

## ‚öôÔ∏è Functionality Deep Dive

* **Connect & Sync:** Users log in with Google. The "Settings" page allows connecting multiple Google accounts, plus LinkedIn, Facebook, HubSpot, and Salesforce accounts. For Facebook, after initial connection, users are guided to select a Page for posting. Calendars are synced to a database to populate the dashboard with upcoming events.
* **Record & Transcribe:** On the dashboard, users toggle "Record Meeting?" for desired events. The system extracts meeting links (Zoom, Meet) and uses Recall.ai to dispatch a bot. A background poller (`BotStatusPoller`) checks for completed recordings and transcripts, saving the data to local `Meeting`, `MeetingTranscript`, and `MeetingParticipant` tables.
* **AI Content Generation:**
    * Once a meeting is processed, an `AIContentGenerationWorker` is enqueued.
    * This worker uses Google Gemini to draft a follow-up email.
    * It also processes all active "Automations" defined by the user. For each automation, it combines the meeting data with the user's `prompt_template` and calls Gemini to generate content (e.g., a LinkedIn post), saving it as an `AutomationResult`.
* **CRM Contact Updates:**
    * From the "Meeting Details" page, open the HubSpot or Salesforce modal.
    * Search for a contact, AI analyzes the transcript for contact info updates.
    * Review suggestions with current vs new values, toggle fields on/off, and apply.
* **AI Chat:**
    * Open the "Ask Anything" panel from any dashboard page.
    * Ask questions about CRM contacts ‚Äî the AI looks up data from connected CRMs and responds.
* **Social Posting:**
    * From the "Meeting Details" page, users can view AI-generated email drafts and posts from their automations.
    * "Copy" buttons are available.
    * "Post" buttons allow direct posting to LinkedIn (as the user) and the selected Facebook Page (as the Page).

---

## üîó HubSpot Integration

### HubSpot OAuth Integration

* **Custom Ueberauth Strategy:** Implemented in `lib/ueberauth/strategy/hubspot.ex`
* **OAuth 2.0 Flow:** Handles authorization code flow with HubSpot's `/oauth/authorize` and `/oauth/v1/token` endpoints
* **Credential Storage:** Credentials stored in `user_credentials` table with `provider: "hubspot"`, including `token`, `refresh_token`, and `expires_at`
* **Token Refresh:**
    * `Workers.CrmTokenRefresher` Oban cron worker (parameterized per provider) runs every 5 minutes to proactively refresh tokens expiring within 10 minutes
    * Internal `with_token_refresh/2` wrapper automatically refreshes expired tokens on API calls and retries the request
    * Refresh failures are logged; users are prompted to re-authenticate if refresh token is invalid

### CRM Modal UI

* **Unified CRM Component:** All CRM providers use `CrmModalComponent` ‚Äî a single parameterized LiveComponent driven by `CRM.ProviderConfig`
* **Contact Search:** Debounced input triggers CRM API search via `CrmApiBehaviour.impl/1`, results displayed in dropdown
* **AI Suggestions:** Generated via `CrmSuggestions.generate_suggestions_from_meeting/3` which calls Gemini with transcript context and provider-specific field config
* **Suggestion Cards:** Each card displays field label, current value (strikethrough), arrow, suggested value, and timestamp link
* **Selective Updates:** Checkbox per field allows selective updates; submit button disabled until at least one field selected
* **Form Submission:** Batch-updates selected contact properties via the provider's `update_contact` callback

---

## Testing

```bash
mix test    # 332 tests, 0 failures
```

Tests use Mox for all external APIs, `Ecto.Adapters.SQL.Sandbox` for DB isolation, and Oban `testing: :manual` mode. Includes property-based tests with StreamData for CRM suggestion merging.

---

## Deployment

The app ships with a multi-stage `Dockerfile` and is pre-configured for Fly.io and Google Cloud Run.

### Deploy to Fly.io

```bash
fly launch                                    # Create app + Postgres
fly secrets set SECRET_KEY_BASE="$(mix phx.gen.secret)" \
  GOOGLE_CLIENT_ID="..." \
  GOOGLE_CLIENT_SECRET="..." \
  # ... all env vars from above
fly deploy                                    # Build and deploy
fly ssh console -C "/app/bin/migrate"         # Run migrations
```

### Production Environment Variables

In addition to the OAuth/API keys above, production requires:

| Variable | Purpose |
|----------|---------|
| `DATABASE_URL` | PostgreSQL connection string (auto-set by Fly Postgres) |
| `SECRET_KEY_BASE` | Generate with `mix phx.gen.secret` |
| `PHX_HOST` | Production hostname (e.g. `myapp.fly.dev`) |
| `PORT` | Server port (default `4000`) |

---

## ‚ö†Ô∏è Known Issues & Limitations

* **Facebook Posting & App Review:**
    * Posting to Facebook is implemented via the Graph API to a user-managed Page.
    * Full functionality for all users (especially those not app administrators/developers/testers) typically requires a thorough app review process by Meta, potentially including Business Verification. This is standard for apps using Page APIs.
    * During development, posting will be most reliable for app admins to Pages they directly manage.
* **Prompt Templating for Automations:** The current automation prompt templating is basic (string replacement). A more sophisticated templating engine (e.g., EEx or a dedicated library) would be a future improvement.
* **Agenda Integration:** Currently we only sync when the calendar event has a `hangoutLink` or `location` field with a zoom or google meet link.

---

## üìö Learn More (Phoenix Framework)

* Official website: https://www.phoenixframework.org/
* Guides: https://hexdocs.pm/phoenix/overview.html
* Docs: https://hexdocs.pm/phoenix
* Forum: https://elixirforum.com/c/phoenix-forum
* Source: https://github.com/phoenixframework/phoenix
